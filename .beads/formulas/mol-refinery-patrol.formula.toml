description = """
Merge queue processor patrol loop.

The Refinery is the Engineer in the engine room. You process polecat branches, merging them to the default branch one at a time with sequential rebasing.

**The Scotty Test**: Before proceeding past any failure, ask yourself: "Would Scotty walk past a warp core leak because it existed before his shift?"

## Merge Flow

The Refinery receives MERGE_READY mail from Witnesses when polecats complete work:

```
Witness                    Refinery                      Git
   │                          │                           │
   │ MERGE_READY              │                           │
   │─────────────────────────>│                           │
   │                          │                           │
   │                    (verify branch)                   │
   │                          │ fetch & rebase            │
   │                          │──────────────────────────>│
   │                          │                           │
   │                    (run tests)                       │
   │                          │                           │
   │                    (if pass)                         │
   │                          │ merge & push              │
   │                          │──────────────────────────>│
   │                          │                           │
   │ MERGED                   │                           │
   │<─────────────────────────│                           │
   │                          │                           │
```

After successful merge, Refinery sends MERGED mail back to Witness so it can
complete cleanup (nuke the polecat worktree)."""
formula = "mol-refinery-patrol"
version = 8

[[steps]]
id = "inbox-check"
title = "Check refinery mail"
description = """
Check mail for MERGE_READY submissions, escalations, and messages.

**1. Detect the default branch (used throughout this workflow):**
```bash
DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD --short | sed 's,.*/,,')
echo "Default branch: $DEFAULT_BRANCH"
```

**2. Check mail:**
```bash
gt mail inbox
```

For each message:

**MERGE_READY**:
A polecat's work is ready for merge. Extract details and track for processing.

```bash
# Parse MERGE_READY message body:
# Branch: <branch>
# Issue: <issue-id>
# Polecat: <polecat-name>
# MR: <mr-bead-id>
# Verified: clean git state, issue closed

# Track in your merge queue for this patrol cycle:
# - Branch name
# - Issue ID
# - Polecat name (REQUIRED for MERGED notification)
# - MR bead ID (REQUIRED for closing after merge)
```

**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them
in merge-push step to send MERGED notification, close the MR bead, and archive the mail.

Mark as read. The work will be processed in queue-scan/process-branch.
**Do NOT archive yet** - archive after merge/reject decision in merge-push step.

**PATROL: Wake up**:
Witness detected MRs waiting but refinery idle. Acknowledge and archive:
```bash
gt mail archive <message-id>
```

**HELP / Blocked**:
Assess and respond. If you can't help, escalate to Mayor.
Archive after handling:
```bash
gt mail archive <message-id>
```

**HANDOFF**:
Read predecessor context. Check for in-flight merges.
Archive after absorbing context:
```bash
gt mail archive <message-id>
```

**Hygiene principle**: Archive messages after they're fully processed.
Keep only: pending MRs in queue. Inbox should be near-empty."""

[[steps]]
id = "queue-scan"
title = "Scan merge queue"
needs = ["inbox-check"]
description = """
Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.

```bash
git fetch --prune origin
gt mq list <rig>
```

The beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`
as branches may exist without MR beads, or MR beads may exist for already-merged work.

If queue empty, skip to context-check step.

For each MR in the queue, verify the branch still exists:
```bash
git branch -r | grep <branch>
```

If branch doesn't exist for a queued MR:
- Close the MR bead: `bd close <mr-id> --reason "Branch no longer exists"`
- Remove from processing queue

Track verified MR list for this cycle."""

[[steps]]
id = "detect-repo-protection"
title = "Detect repository branch protection"
needs = ["queue-scan"]
description = """
Detect branch protection status ONCE at the start of processing - this determines the merge strategy for ALL items.

**CRITICAL**: This MUST complete before processing any branches. Do NOT skip this step.

**Step 1: Get repo info**
```bash
REPO_INFO=$(gh repo view --json owner,name -q '"\(.owner.login)/\(.name)"')
echo "Repo: $REPO_INFO"
```

**Step 2: Check protection status**
```bash
if gh api "repos/${REPO_INFO}/branches/${DEFAULT_BRANCH}/protection" &>/dev/null; then
    BRANCH_PROTECTED="true"
else
    BRANCH_PROTECTED="false"
fi
echo "Default branch protection: $BRANCH_PROTECTED"
```

**Step 3: Verify detection succeeded**
- If REPO_INFO is empty or malformed, STOP and investigate
- If the gh api call fails with non-404 error, STOP and investigate
- Only proceed when you have a definitive true/false for BRANCH_PROTECTED

**IMPORTANT**: Track BRANCH_PROTECTED for the entire patrol cycle. This value determines:
- PROTECTED (true): Use PR-based workflow for ALL merges
- UNPROTECTED (false): Use direct push workflow

**Why detect early?** Branch protection determines the ENTIRE merge strategy. Detecting late
leads to wasted rebase work and potential accidental direct pushes to protected branches."""

[[steps]]
id = "check-mr-pr-status"
title = "Check existing PR status for MR items"
needs = ["detect-repo-protection"]
description = """
For protected branches, check if MR beads already have associated PRs before processing.

**Skip this step if BRANCH_PROTECTED=false** (unprotected repos don't use PRs).

For each MR in the queue:

**Step 1: Check for PR label on MR bead**
```bash
PR_LABEL=$(bd show <mr-bead-id> --json | jq -r '.[0].labels[]? | select(startswith("pr:"))' | head -1)
```

**Step 2: Determine PR state**
```bash
if [ -n "$PR_LABEL" ]; then
    PR_NUMBER="${PR_LABEL#pr:}"
    PR_JSON=$(gh pr view "$PR_NUMBER" --json state,mergedAt,url 2>/dev/null)
    PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
else
    # Check GitHub directly
    PR_JSON=$(gh pr list --head "<polecat-branch>" --state all --json number,state,mergedAt,url --jq '.[0]' 2>/dev/null)
    if [ -z "$PR_JSON" ] || [ "$PR_JSON" = "null" ]; then
        PR_STATE="NONE"
    else
        PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
        PR_NUMBER=$(echo "$PR_JSON" | jq -r '.number')
        # Backfill the label
        bd update <mr-bead-id> --add-label="pr:${PR_NUMBER}"
    fi
fi
```

**Step 3: Categorize MRs by PR state**

| PR State | Action |
|----------|--------|
| **NONE** | Needs full processing: rebase, test, create PR |
| **OPEN** | Skip rebase/test - PR already in GitHub workflow (see below) |
| **MERGED** | Skip rebase/test - go directly to cleanup |
| **CLOSED** | Skip rebase/test - go directly to close MR bead |

**For OPEN PRs - check mergeable status:**
```bash
PR_MERGEABLE=$(gh pr view $PR_NUMBER --json mergeable -q '.mergeable')
```
- `MERGEABLE` or `UNKNOWN` → Skip entirely, PR is waiting for CI/reviews
- `CONFLICTING` → Needs rebase update only (no local tests needed, CI will run)

Track for each MR:
- mr_bead_id
- branch
- pr_state (NONE/OPEN/MERGED/CLOSED)
- pr_number (if exists)
- pr_mergeable (for OPEN PRs only)

**Why check early?** Once a PR exists, GitHub CI handles testing. No need to duplicate
locally. Only intervene if PR has conflicts that need rebasing."""

[[steps]]
id = "process-branch"
title = "Mechanical rebase"
needs = ["check-mr-pr-status"]
description = """
Pick next branch from queue. Attempt mechanical rebase on current default branch.

**Pre-check based on PR state from check-mr-pr-status step:**

| PR State | Mergeable | Action |
|----------|-----------|--------|
| MERGED | - | Skip to merge-push for cleanup |
| CLOSED | - | Skip to merge-push for cleanup |
| OPEN | MERGEABLE/UNKNOWN | **Skip entirely** - PR in GitHub workflow |
| OPEN | CONFLICTING | Rebase only, push to update PR, skip tests |
| NONE | - | Full processing: rebase, test, create PR |

**For OPEN+CONFLICTING:** Only rebase and push to update the PR branch. Do NOT run tests
locally - GitHub CI will run them after the push.

**For PR_STATE=NONE (needs full processing):**

**Step 1: Checkout and attempt rebase**
```bash
git checkout -b temp origin/<polecat-branch>
git rebase origin/$DEFAULT_BRANCH
```

**Step 2: Check rebase result**

The rebase exits with:
- Exit code 0: Success - proceed to run-tests
- Exit code 1 (conflicts): Conflict detected - proceed to Step 3

To detect conflict state after rebase fails:
```bash
# Check if we're in a conflicted rebase state
ls .git/rebase-merge 2>/dev/null && echo "CONFLICT_STATE"
```

**Step 3: Handle conflicts (if any)**

If rebase SUCCEEDED (exit code 0):
- Skip to run-tests step (continue normal merge flow)

If rebase FAILED with conflicts:

1. **Abort the rebase** (DO NOT leave repo in conflicted state):
```bash
git rebase --abort
```

2. **Record conflict metadata**:
```bash
# Capture default branch SHA for reference
MAIN_SHA=$(git rev-parse origin/$DEFAULT_BRANCH)
BRANCH_SHA=$(git rev-parse origin/<polecat-branch>)
```

3. **Create conflict-resolution task**:
```bash
bd create --type=task --priority=1 \
  --title="Resolve merge conflicts: <original-issue-title>" \
  --description="## Conflict Resolution Required

Original MR: <mr-bead-id>
Branch: <polecat-branch>
Original Issue: <issue-id>
Conflict with default branch at: ${MAIN_SHA}
Branch SHA: ${BRANCH_SHA}

## Instructions
1. Clone/checkout the branch
2. Rebase on current default branch: git rebase origin/<default-branch>
3. Resolve conflicts
4. Force push: git push -f origin <branch>
5. Close this task when done

The MR will be re-queued for processing after conflicts are resolved."
```

4. **Skip this MR** (do NOT delete branch or close MR bead):
- Leave branch intact for conflict resolution
- Leave MR bead open (will be re-processed after resolution)
- Continue to loop-check for next branch

**CRITICAL**: Never delete a branch that has conflicts. The branch contains
the original work and must be preserved for conflict resolution.

Track: rebase result (success/conflict), conflict task ID if created."""

[[steps]]
id = "run-tests"
title = "Run test suite"
needs = ["process-branch"]
description = """
Run the test suite.

```bash
go test ./...
```

Track results: pass count, fail count, specific failures."""

[[steps]]
id = "handle-failures"
title = "Handle test failures"
needs = ["run-tests"]
description = """
**VERIFICATION GATE**: This step enforces the Beads Promise.

If tests PASSED: This step auto-completes. Proceed to merge.

If tests FAILED:
1. Diagnose: Is this a branch regression or pre-existing on the default branch?
2. If branch caused it:
   - Abort merge
   - Notify polecat: "Tests failing. Please fix and resubmit."
   - Skip to loop-check
3. If pre-existing on the default branch:
   - Option A: Fix it yourself (you're the Engineer!)
   - Option B: File a bead: bd create --type=bug --priority=1 --title="..."

**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:
- Tests passing, OR
- Fix committed, OR
- Bead filed for the failure

This is non-negotiable. Never disavow. Never "note and proceed." """

[[steps]]
id = "merge-push"
title = "Merge and push to default branch"
needs = ["handle-failures"]
description = """
Merge to default branch. Path determined by BRANCH_PROTECTED from detect-repo-protection step.

**PREREQUISITE**: BRANCH_PROTECTED must be set from the detect-repo-protection step (runs early in cycle).
If BRANCH_PROTECTED is not set, STOP - do not proceed with any merge attempt.

**PR_STATE from check-mr-pr-status**: Use this to handle already-merged or closed PRs efficiently.

---

## UNPROTECTED PATH (BRANCH_PROTECTED=false)

If unprotected, use the direct merge-push workflow:

**Step A-1: Merge and Push**
```bash
git checkout $DEFAULT_BRANCH
git merge --ff-only temp
git push origin $DEFAULT_BRANCH
```

**Step A-2: Send MERGED Notification (REQUIRED)**
```bash
gt mail send <rig>/witness -s "MERGED <polecat-name>" -m "Branch: <branch>
Issue: <issue-id>
Merged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
```

**Step A-3: Close MR Bead (REQUIRED)**

⚠️ **VERIFICATION BEFORE CLOSING**: Confirm the work is actually on the default branch:
```bash
git log origin/$DEFAULT_BRANCH --oneline | grep "<issue-id>"
```

```bash
bd close <mr-bead-id> --reason "Merged to $DEFAULT_BRANCH at $(git rev-parse --short HEAD)"
```

⚠️ **DO NOT PROCEED TO CLEANUP UNTIL STEPS A-2 and A-3 ARE COMPLETE**

**Step A-4: Archive and Cleanup**
```bash
gt mail archive <merge-ready-message-id>
git branch -d temp
git push origin --delete <polecat-branch>
```

Skip to loop-check.

---

## PROTECTED PATH (BRANCH_PROTECTED=true)

If protected, use the PR-based workflow:

**Step B-1: Check for Existing PR**

```bash
# First, check if MR bead already has a PR label (fast path)
PR_LABEL=$(bd show <mr-bead-id> --json | jq -r '.[0].labels[]? | select(startswith("pr:"))' | head -1)

if [ -n "$PR_LABEL" ]; then
    # PR was previously created - extract number from label
    PR_NUMBER="${PR_LABEL#pr:}"

    # Query current PR state from GitHub
    PR_JSON=$(gh pr view "$PR_NUMBER" --json state,mergedAt,url 2>/dev/null)
    PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
    PR_URL=$(echo "$PR_JSON" | jq -r '.url')
else
    # No PR label - check GitHub directly
    PR_JSON=$(gh pr list --head "<polecat-branch>" --state all --json number,state,mergedAt,url --jq '.[0]' 2>/dev/null)

    if [ -z "$PR_JSON" ] || [ "$PR_JSON" = "null" ]; then
        PR_STATE="NONE"
    else
        PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
        PR_NUMBER=$(echo "$PR_JSON" | jq -r '.number')
        PR_URL=$(echo "$PR_JSON" | jq -r '.url')

        # Backfill the label for future cycles
        bd update <mr-bead-id> --add-label="pr:${PR_NUMBER}"
    fi
fi
```

**Step B-2: Handle PR State**

| PR State | Action |
|----------|--------|
| **NONE** | Push rebased branch, create PR, skip to loop-check |
| **OPEN** | Check for merge conflicts; if clean, skip to loop-check |
| **MERGED** | Execute post-merge cleanup (MERGED mail, close MR, archive) |
| **CLOSED** | Close MR bead with reason, archive mail, clean up |

---

### NONE - Create PR

```bash
# Push rebased commits to origin (update the polecat branch)
git push -f origin temp:<polecat-branch>

# Create PR
PR_URL=$(gh pr create \\
    --head "<polecat-branch>" \\
    --base "$DEFAULT_BRANCH" \\
    --title "[<issue-id>] <issue-title>" \\
    --body "## Merge Request

Original Issue: <issue-id>
MR Bead: <mr-bead-id>
Polecat: <polecat-name>

---
*Auto-created by Refinery. Tests passed locally.*")

PR_NUMBER=$(gh pr view "<polecat-branch>" --json number -q '.number')

# Add PR number as label to MR bead (audit trail + easy lookup)
bd update <mr-bead-id> --add-label="pr:${PR_NUMBER}"

# Cleanup temp branch (required for next process-branch iteration)
git branch -D temp

# Do NOT archive MERGE_READY mail - work not complete
# Do NOT close MR bead - work not complete
# Skip to loop-check
```

---

### OPEN - Wait for Merge (or Update if Conflicts)

```bash
# Check if PR has merge conflicts
PR_MERGEABLE=$(gh pr view <polecat-branch> --json mergeable -q '.mergeable')

if [ "$PR_MERGEABLE" = "CONFLICTING" ]; then
    # PR has conflicts - update it with rebased commits
    git push -f origin temp:<polecat-branch>
    echo "Updated PR with rebased commits"
fi

# Cleanup temp branch (required for next process-branch iteration)
git branch -D temp

# PR is waiting for checks/reviews (or just updated) - nothing more to do
# Skip to loop-check
```

---

### MERGED - Post-Merge Cleanup

```bash
# 1. Send MERGED mail to witness (include PR info)
gt mail send <rig>/witness -s "MERGED <polecat-name>" -m "Branch: <polecat-branch>
Issue: <issue-id>
PR-Number: ${PR_NUMBER}
PR-URL: ${PR_URL}
Merged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

# 2. Close MR bead
bd close <mr-bead-id> --reason "Merged via PR #${PR_NUMBER}"

# 3. Archive MERGE_READY mail
gt mail archive <merge-ready-message-id>

# 4. Cleanup local temp branch
git branch -D temp

# 5. Verify remote branch deleted (GitHub auto-delete or manual)
if git ls-remote --exit-code origin refs/heads/<polecat-branch> &>/dev/null; then
    git push origin --delete <polecat-branch>
fi
```

---

### CLOSED (Not Merged) - Abort

```bash
# 1. Get close reason from GitHub
CLOSE_INFO=$(gh pr view <polecat-branch> --json body,closedAt -q '"Closed at: \\(.closedAt)"')

# 2. Close MR bead
bd close <mr-bead-id> --reason "PR closed without merge. ${CLOSE_INFO}"

# 3. Archive MERGE_READY mail
gt mail archive <merge-ready-message-id>

# 4. Cleanup
git branch -D temp
git push origin --delete <polecat-branch> 2>/dev/null || true
```

---

**VERIFICATION GATE (Both Paths)**: You CANNOT proceed to loop-check without:
- For UNPROTECTED: MERGED mail sent, MR bead closed, mail archived
- For PROTECTED+MERGED: MERGED mail sent, MR bead closed, mail archived
- For PROTECTED+NONE/OPEN: PR created/updated, MR bead has pr: label
- For PROTECTED+CLOSED: MR bead closed, mail archived"""

[[steps]]
id = "loop-check"
title = "Check for more work"
needs = ["merge-push"]
description = """
More branches to process?

**Entry paths:**
- Normal: After successful merge-push (direct or via merged PR)
- Conflict-skip: After process-branch created conflict-resolution task
- PR-waiting: After creating or updating a PR (protected branch path)

If yes: Return to process-branch with next branch.
If no: Continue to generate-summary.

**Track for this cycle:**
- branches_direct_merged: count and names of branches merged via direct push (unprotected)
- branches_pr_created: count and names of PRs created this cycle (protected, new)
- branches_pr_merged: count and names of PRs that completed merge this cycle
- branches_pr_waiting: count and names of PRs still open, waiting for checks/reviews
- branches_pr_closed: count and names of PRs closed without merge this cycle
- branches_conflict: count and names of branches skipped due to conflicts
- conflict_tasks: IDs of conflict-resolution tasks created

This tracking feeds into generate-summary for the patrol digest."""

[[steps]]
id = "generate-summary"
title = "Generate handoff summary"
needs = ["loop-check"]
description = """
Summarize this patrol cycle.

**VERIFICATION**: Before generating summary, confirm for each merged branch:
- [ ] MERGED mail was sent to witness
- [ ] MR bead was closed
- [ ] MERGE_READY mail archived

If any notifications or archiving were missed, do them now!

Include in summary:

**Direct Merges (unprotected):**
- Branches direct merged (count, names)
- MERGED mails sent (count - should match direct merges)
- MR beads closed (count - should match direct merges)
- MERGE_READY mails archived (count - should match direct merges)

**PR Workflow (protected):**
- PRs created this cycle (count, PR numbers, branch names)
- PRs merged this cycle (count, PR numbers) - includes MERGED mails sent
- PRs waiting for checks/reviews (count, PR numbers)
- PRs closed without merge (count, PR numbers)

**Other:**
- Test results (pass/fail)
- Branches with conflicts (count, names)
- Conflict-resolution tasks created (IDs)
- Issues filed (if any)
- Any escalations sent

**Conflict tracking is important** for monitoring MQ health. If many branches
conflict, it may indicate the default branch is moving too fast or branches are too stale.

**PR tracking is important** for monitoring protected branch workflows. If many PRs
are waiting, it may indicate CI is slow or reviews are needed.

This becomes the digest when the patrol is squashed."""

[[steps]]
id = "context-check"
title = "Check own context limit"
needs = ["generate-summary"]
description = """
Check own context usage.

If context is HIGH (>80%):
- Write handoff summary
- Prepare for burn/respawn

If context is LOW:
- Can continue processing"""

[[steps]]
id = "patrol-cleanup"
title = "End-of-cycle inbox hygiene"
needs = ["context-check"]
description = """
Verify inbox hygiene before ending patrol cycle.

**Step 1: Check inbox state**
```bash
gt mail inbox
```

Inbox should contain ONLY:
- Unprocessed MERGE_READY messages (will process next cycle)
- Active work items

**Step 2: Archive any stale messages**

Look for messages that were processed but not archived:
- PATROL: Wake up that was acknowledged → archive
- HELP/Blocked that was handled → archive
- MERGE_READY where merge completed but archive was missed → archive

```bash
# For each stale message found:
gt mail archive <message-id>
```

**Step 3: Check for orphaned MR beads**

Look for open MR beads with no corresponding branch:
```bash
bd list --type=merge-request --status=open
```

For each open MR bead:
1. Check if branch exists: `git ls-remote origin refs/heads/<branch>`
2. If branch gone, verify work is on default branch: `git log origin/$DEFAULT_BRANCH --oneline | grep "<source_issue>"`
3. If work on default branch → close MR with reason "Merged (verified on default branch)"
4. If work NOT on default branch → investigate before closing:
   - Check source_issue validity (should be gt-xxxxx, not branch name)
   - Search reflog/dangling commits if possible
   - If unverifiable, close with reason "Unverifiable - no audit trail"
   - File bead if this indicates lost work

**NEVER close an MR bead without verifying the work landed or is unrecoverable.**

**Step 4: Check for orphaned PRs (protected branch repos)**

For repositories with protected default branches, check for PRs with no corresponding MR bead:

```bash
# Get repo info
REPO_INFO=$(gh repo view --json owner,name -q '"\\(.owner.login)/\\(.name)"')

# List open PRs created by refinery (auto-created)
OPEN_PRS=$(gh pr list --state open --json number,headRefName,body --jq '.[] | select(.body | contains("Auto-created by Refinery"))')
```

For each open PR:
1. Extract MR bead ID from PR body (if present)
2. Check if MR bead exists: `bd show <mr-bead-id>`
3. If MR bead doesn't exist or is closed:
   - This is an orphaned PR
   - Check if branch has been merged: `git branch -r --merged origin/$DEFAULT_BRANCH | grep <branch>`
   - If merged → close PR with comment "Work merged. MR bead closed."
   - If not merged → flag for investigation (branch may need manual review)

**Note**: This step only applies to repos with protected branches. Skip if BRANCH_PROTECTED
from detect-repo-protection step is false.

**Goal**: Inbox should have ≤3 active messages at end of cycle.
Keep only: pending MRs in queue."""

[[steps]]
id = "burn-or-loop"
title = "Burn and respawn or loop"
needs = ["patrol-cleanup"]
description = """
End of patrol cycle decision.

**Step 1: Estimate remaining context**

Ask yourself:
- Have I processed many branches this cycle?
- Is the conversation getting long?
- Am I starting to lose track of earlier context?

Rule of thumb: If you've done 3+ merges or processed significant cleanup work,
it's time for a fresh session.

**Step 2: Decision tree**

```
                    ┌─────────────────┐
                    │  Queue empty?   │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │ YES                         │ NO
              ▼                             ▼
    ┌─────────────────────┐      ┌─────────────────────┐
    │ EXIT CLEANLY        │      │ Context HIGH?       │
    │ (no handoff)        │      └──────────┬──────────┘
    │ Daemon will wake    │                 │
    │ when work arrives   │      ┌──────────┴──────────┐
    └─────────────────────┘      │ YES                 │ NO
                                 ▼                     ▼
                      ┌──────────────────┐  ┌──────────────────┐
                      │ gt handoff       │  │ Loop: spawn wisp │
                      │ (successor       │  │ return to        │
                      │ continues queue) │  │ inbox-check      │
                      └──────────────────┘  └──────────────────┘
```

**If queue EMPTY:**
- Squash wisp with summary digest
- **EXIT cleanly - DO NOT use gt handoff**
- The daemon/witness will wake you when new MERGE_READY mail arrives
- Prevents infinite empty patrol loops

```bash
bd mol squash <wisp-id> --summary="Patrol complete: queue empty"
# Just exit - no handoff needed
```

**If queue NON-EMPTY AND context HIGH:**
- Squash wisp with summary digest
- Use `gt handoff` so successor can continue processing:

```bash
gt handoff -s "Patrol handoff" -m "Context limit reached.
Queue: N branches remaining
Processed: X merges, Y PRs created
Next: Continue processing queue"
```

**If queue NON-EMPTY AND context LOW:**
- Squash this wisp to digest
- Spawn fresh patrol wisp
- Return to inbox-check

```bash
bd mol squash <wisp-id> --summary="Patrol cycle: merged X branches"
bd mol spawn mol-refinery-patrol --wisp --assignee=refinery
# Continue to inbox-check...
```

**Why no handoff when queue empty?**
Using `gt handoff` when queue is empty creates an infinite loop:
handoff → gt prime → create patrol → find empty queue → handoff → repeat

The witness sends MERGE_READY mail when polecats complete work. The daemon
monitors mail and wakes the refinery when there's actual work to do."""
