description = """
Merge queue processor patrol loop.

The Refinery is the Engineer in the engine room. You process polecat branches, merging them to the default branch one at a time with sequential rebasing.

**The Scotty Test**: Before proceeding past any failure, ask yourself: "Would Scotty walk past a warp core leak because it existed before his shift?"

## Merge Flow

The Refinery receives MERGE_READY mail from Witnesses when polecats complete work:

```
Witness                    Refinery                      Git
   │                          │                           │
   │ MERGE_READY              │                           │
   │─────────────────────────>│                           │
   │                          │                           │
   │                    (verify branch)                   │
   │                          │ fetch & rebase            │
   │                          │──────────────────────────>│
   │                          │                           │
   │                    (run tests)                       │
   │                          │                           │
   │                    (if pass)                         │
   │                          │ merge & push              │
   │                          │──────────────────────────>│
   │                          │                           │
   │ MERGED                   │                           │
   │<─────────────────────────│                           │
   │                          │                           │
```

For protected branches, PRs are created and tracked via gh:pr gates. The poll-pr-gates
plugin monitors PR status and closes gates when PRs merge, triggering GATE_CLEARED mail."""
formula = "mol-refinery-patrol"
version = 10

[[steps]]
id = "inbox-check"
title = "Check refinery mail"
description = """
Check mail for MERGE_READY submissions, gate notifications, and messages.

```bash
gt mail inbox
```

For each message:

**MERGE_READY**:
A polecat's work is ready for merge. Extract details and track for processing.

```bash
# Parse MERGE_READY message body:
# Branch: <branch>
# Issue: <issue-id>
# Polecat: <polecat-name>
# MR: <mr-bead-id>
# Verified: clean git state, issue closed

# Track in your merge queue for this patrol cycle:
# - Branch name
# - Issue ID
# - Polecat name (REQUIRED for MERGED notification)
# - MR bead ID (REQUIRED for closing after merge)
```

**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them
in merge-push step to send MERGED notification, close the MR bead, and archive the mail.

Mark as read. The work will be processed in queue-scan/process-branch.
**Do NOT archive yet** - archive after merge/reject decision in merge-push step.

**GATE_CLEARED** (from poll-pr-gates plugin via gt gate wake):
A PR has merged. Execute post-merge cleanup:

```bash
# Extract gate ID from mail subject/body
GATE_ID=<from mail>

# Find MR bead with this gate label
MR_BEAD=$(bd list --label "gate:${GATE_ID}" --json | jq -r '.[0].id')

if [ -z "$MR_BEAD" ]; then
  echo "Warning: No MR bead found for gate ${GATE_ID}"
  gt mail archive <message-id>
  # Continue - gate may have been from different workflow
else
  # Get PR number and branch from MR bead
  MR_JSON=$(bd show "$MR_BEAD" --json)
  PR_NUMBER=$(echo "$MR_JSON" | jq -r '.[0].labels[]? | select(startswith("pr:"))' | sed 's/pr://' | head -1)
  BRANCH=$(echo "$MR_JSON" | jq -r '.[0].description' | grep -E "^branch:" | cut -d' ' -f2)
  POLECAT=$(echo "$MR_JSON" | jq -r '.[0].description' | grep -E "^polecat:" | cut -d' ' -f2)
  ISSUE=$(echo "$MR_JSON" | jq -r '.[0].description' | grep -E "^issue:" | cut -d' ' -f2)
  RIG=$(echo "$MR_JSON" | jq -r '.[0].description' | grep -E "^rig:" | cut -d' ' -f2)

  # Send MERGED notification to witness
  gt mail send "${RIG}/witness" -s "MERGED ${POLECAT}" -m "Branch: ${BRANCH}
Issue: ${ISSUE}
PR-Number: ${PR_NUMBER}
Merged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

  # Close MR bead
  bd close "$MR_BEAD" --reason "Merged via PR #${PR_NUMBER}"

  # Find and archive the original MERGE_READY mail for this MR
  # (may need to search by branch or MR bead reference)

  # Delete remote branch if still exists
  git push origin --delete "$BRANCH" 2>/dev/null || true

  gt mail archive <message-id>
fi
```

**PATROL: Wake up**:
Witness detected MRs waiting but refinery idle. Acknowledge and archive:
```bash
gt mail archive <message-id>
```

**HELP / Blocked**:
Assess and respond. If you can't help, escalate to Mayor.
Archive after handling:
```bash
gt mail archive <message-id>
```

**HANDOFF**:
Read predecessor context. Check for in-flight merges.
Archive after absorbing context:
```bash
gt mail archive <message-id>
```

**Hygiene principle**: Archive messages after they're fully processed.
Keep only: pending MRs in queue. Inbox should be near-empty."""

[[steps]]
id = "queue-scan"
title = "Scan merge queue"
needs = ["inbox-check"]
description = """
Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.

```bash
git fetch --prune origin
gt mq list <rig>
```

The beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`
as branches may exist without MR beads, or MR beads may exist for already-merged work.

If queue empty, skip to context-check step.

For each MR in the queue:

**Step 1: Check for existing gate (protected branch workflow)**
```bash
GATE_LABEL=$(bd show <mr-bead-id> --json | jq -r '.[0].labels[]? | select(startswith("gate:"))' | head -1)
```

If gate exists: This MR has a PR waiting for merge. Skip processing - the poll-pr-gates
plugin will close the gate when the PR merges.

**Step 2: Verify branch exists (for MRs without gates)**
```bash
git branch -r | grep <branch>
```

If branch doesn't exist for a queued MR without a gate:
- Close the MR bead: `bd close <mr-id> --reason "Branch no longer exists"`
- Remove from processing queue

Track:
- MRs with gates (skip - waiting for PR merge)
- MRs without gates (process this cycle)"""

[[steps]]
id = "detect-default-branch"
title = "Detect default branch"
needs = ["queue-scan"]
description = """
Detect the repository's default branch ONCE at the start of processing.

**CRITICAL: This is an INTERNAL variable, not a shell variable.**
You must remember this value and use it in ALL subsequent steps.

**Step 1: Detect the default branch**
```bash
git symbolic-ref refs/remotes/origin/HEAD --short | sed 's,.*/,,'
```

Example output: `main`, `master`, `develop`, etc.

**Step 2: Record and announce**
After running the command, state clearly:
> "Default branch detected: [branch-name]. I will use this value for all rebase and PR operations."

**REMEMBER for this patrol cycle:**
- `DEFAULT_BRANCH` = the value you just detected (e.g., "main", "develop")

This value is used in:
- `process-branch`: rebase target (`origin/<DEFAULT_BRANCH>`)
- `merge-push`: PR base branch (`--base "<DEFAULT_BRANCH>"`)

**Why detect here?** The default branch varies by repository. Hardcoding "main" breaks
repos using "master", "develop", or custom branch names. Detect once, use everywhere."""

[[steps]]
id = "detect-repo-protection"
title = "Detect repository branch protection"
needs = ["detect-default-branch"]
description = """
Detect branch protection status ONCE at the start of processing.

**CRITICAL**: This MUST complete before processing any branches.

**Step 1: Get repo info**
```bash
REPO_INFO=$(gh repo view --json owner,name -q '.owner.login + "/" + .name')
echo "Repo: $REPO_INFO"
```

**Step 2: Check protection status**

Using the `DEFAULT_BRANCH` value you recorded:
```bash
gh api "repos/${REPO_INFO}/branches/<DEFAULT_BRANCH>/protection" 2>/dev/null
```

- If the command succeeds (exit 0): `BRANCH_PROTECTED = true`
- If the command fails with 404: `BRANCH_PROTECTED = false`
- If other error: STOP and investigate

State clearly: "Branch protection for [DEFAULT_BRANCH]: [true/false]"

**IMPORTANT**: Track BRANCH_PROTECTED for the entire patrol cycle. This value determines:
- PROTECTED (true): Use PR-based workflow with gh:pr gates
- UNPROTECTED (false): Use direct push workflow"""

[[steps]]
id = "process-branch"
title = "Mechanical rebase"
needs = ["detect-repo-protection"]
description = """
Pick next branch from queue (MRs without gates only). Attempt mechanical rebase.

**Pre-check**: Skip MRs that have a gate label - they're waiting for PR merge.

**Step 1: Checkout and attempt rebase**

Use the `DEFAULT_BRANCH` value you recorded:
```bash
git checkout -b temp origin/<polecat-branch>
git rebase origin/<DEFAULT_BRANCH>
```

**Step 2: Check rebase result**

- Exit code 0: Success - proceed to run-tests
- Exit code 1 (conflicts): Conflict detected - proceed to Step 3

To detect conflict state:
```bash
ls .git/rebase-merge 2>/dev/null && echo "CONFLICT_STATE"
```

**Step 3: Handle conflicts (if any)**

If rebase SUCCEEDED: Skip to run-tests step.

If rebase FAILED with conflicts:

1. **Abort the rebase**:
```bash
git rebase --abort
```

2. **Record conflict metadata**:
```bash
MAIN_SHA=$(git rev-parse origin/<DEFAULT_BRANCH>)
BRANCH_SHA=$(git rev-parse origin/<polecat-branch>)
```

3. **Create conflict-resolution task**:
```bash
bd create --type=task --priority=1 \
  --title="Resolve merge conflicts: <original-issue-title>" \
  --description="## Conflict Resolution Required

Original MR: <mr-bead-id>
Branch: <polecat-branch>
Original Issue: <issue-id>
Conflict with default branch at: ${MAIN_SHA}

## Instructions
1. Checkout the branch
2. Rebase on current default branch
3. Resolve conflicts
4. Force push
5. Close this task when done"
```

4. **Skip this MR** - leave branch and MR bead intact for resolution.

Track: rebase result (success/conflict), conflict task ID if created."""

[[steps]]
id = "run-tests"
title = "Run test suite"
needs = ["process-branch"]
description = """
Run the test suite.

```bash
go test ./...
```

Track results: pass count, fail count, specific failures."""

[[steps]]
id = "handle-failures"
title = "Handle test failures"
needs = ["run-tests"]
description = """
**VERIFICATION GATE**: This step enforces the Beads Promise.

If tests PASSED: This step auto-completes. Proceed to merge.

If tests FAILED:
1. Diagnose: Is this a branch regression or pre-existing?
2. If branch caused it:
   - Abort merge
   - Notify polecat: "Tests failing. Please fix and resubmit."
   - Skip to loop-check
3. If pre-existing:
   - Option A: Fix it yourself
   - Option B: File a bead: bd create --type=bug --priority=1 --title="..."

**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:
- Tests passing, OR
- Fix committed, OR
- Bead filed for the failure"""

[[steps]]
id = "merge-push"
title = "Merge and push to default branch"
needs = ["handle-failures"]
description = """
Merge to default branch. Path determined by BRANCH_PROTECTED.

**PREREQUISITE**: BRANCH_PROTECTED must be set from detect-repo-protection step.

---

## UNPROTECTED PATH (BRANCH_PROTECTED=false)

Direct merge-push workflow:

**Step A-1: Merge and Push**
```bash
git checkout <DEFAULT_BRANCH>
git merge --ff-only temp
git push origin <DEFAULT_BRANCH>
```

**Step A-2: Send MERGED Notification**
```bash
gt mail send <rig>/witness -s "MERGED <polecat-name>" -m "Branch: <branch>
Issue: <issue-id>
Merged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
```

**Step A-3: Close MR Bead**
```bash
git log origin/<DEFAULT_BRANCH> --oneline | grep "<issue-id>"  # Verify
bd close <mr-bead-id> --reason "Merged to <DEFAULT_BRANCH>"
```

**Step A-4: Archive and Cleanup**
```bash
gt mail archive <merge-ready-message-id>
git branch -d temp
git push origin --delete <polecat-branch>
```

Skip to loop-check.

---

## PROTECTED PATH (BRANCH_PROTECTED=true)

PR-based workflow with gh:pr gate:

**Step B-1: Push rebased branch**
```bash
git push -f origin temp:<polecat-branch>
```

**Step B-2: Create PR**
```bash
PR_URL=$(gh pr create \
    --head "<polecat-branch>" \
    --base "<DEFAULT_BRANCH>" \
    --title "[<issue-id>] <issue-title>" \
    --body "## Merge Request

Original Issue: <issue-id>
MR Bead: <mr-bead-id>
Polecat: <polecat-name>
Rig: <rig>

---
*Auto-created by Refinery. Tests passed locally.*")

PR_NUMBER=$(gh pr view "<polecat-branch>" --json number -q '.number')
echo "Created PR #${PR_NUMBER}: ${PR_URL}"
```

**Step B-3: Create gh:pr gate for async tracking**
```bash
GATE_ID=$(bd gate create --await "gh:pr:${PR_NUMBER}" \
    --title "PR #${PR_NUMBER} merge" \
    --description "Waiting for PR to be reviewed and merged" \
    --json | jq -r '.id')
echo "Created gate: ${GATE_ID}"
```

**Step B-4: Label MR bead with PR and gate references**
```bash
bd update <mr-bead-id> \
    --add-label="pr:${PR_NUMBER}" \
    --add-label="gate:${GATE_ID}"
```

**Step B-5: Cleanup and continue**
```bash
git branch -D temp
```

**DO NOT archive MERGE_READY mail** - work not complete yet.
**DO NOT close MR bead** - waiting for PR merge.
**DO NOT wait** - continue to next MR immediately.

The poll-pr-gates plugin will close the gate when the PR merges,
triggering GATE_CLEARED mail which handles post-merge cleanup.

Skip to loop-check.

---

**VERIFICATION GATE**:
- UNPROTECTED: MERGED mail sent, MR bead closed, mail archived
- PROTECTED: PR created, gate created, MR bead labeled"""

[[steps]]
id = "loop-check"
title = "Check for more work"
needs = ["merge-push"]
description = """
More branches to process?

**Entry paths:**
- Normal: After successful merge-push (direct or PR created)
- Conflict-skip: After process-branch created conflict-resolution task

If yes: Return to process-branch with next branch.
If no: Continue to generate-summary.

**Track for this cycle:**
- branches_direct_merged: count (unprotected path)
- branches_pr_created: count and PR numbers (protected path)
- branches_conflict: count (skipped due to conflicts)
- branches_waiting: count (MRs with existing gates, skipped)"""

[[steps]]
id = "generate-summary"
title = "Generate handoff summary"
needs = ["loop-check"]
description = """
Summarize this patrol cycle.

**VERIFICATION**: Before generating summary, confirm for direct merges:
- [ ] MERGED mail was sent to witness
- [ ] MR bead was closed
- [ ] MERGE_READY mail archived

If any were missed, do them now!

Include in summary:

**Direct Merges (unprotected):**
- Branches merged (count, names)
- MERGED mails sent

**PR Workflow (protected):**
- PRs created this cycle (count, PR numbers)
- Gates created (count, gate IDs)
- MRs waiting for existing PRs (count)

**Other:**
- Test results (pass/fail)
- Branches with conflicts (count, names)
- Conflict-resolution tasks created (IDs)
- GATE_CLEARED mails processed (post-merge cleanups)"""

[[steps]]
id = "context-check"
title = "Check own context limit"
needs = ["generate-summary"]
description = """
Check own context usage.

If context is HIGH (>80%):
- Write handoff summary
- Prepare for burn/respawn

If context is LOW:
- Can continue processing"""

[[steps]]
id = "patrol-cleanup"
title = "End-of-cycle inbox hygiene"
needs = ["context-check"]
description = """
Verify inbox hygiene before ending patrol cycle.

**Step 1: Check inbox state**
```bash
gt mail inbox
```

Inbox should contain ONLY:
- Unprocessed MERGE_READY messages (will process next cycle)
- Active work items

**Step 2: Archive stale messages**

Look for messages that were processed but not archived:
- PATROL: Wake up that was acknowledged -> archive
- HELP/Blocked that was handled -> archive
- GATE_CLEARED that was processed -> archive

```bash
gt mail archive <message-id>
```

**Step 3: Check for orphaned MR beads**

Look for open MR beads with no corresponding branch AND no gate:
```bash
bd list --type=merge-request --status=open
```

For each open MR bead:
1. Check if it has a gate label (waiting for PR) -> skip
2. Check if branch exists: `git ls-remote origin refs/heads/<branch>`
3. If branch gone, verify work on default branch
4. If verified merged -> close MR
5. If unverifiable -> investigate

**Goal**: Inbox should have <=3 active messages at end of cycle."""

[[steps]]
id = "burn-or-loop"
title = "Burn and respawn or loop"
needs = ["patrol-cleanup"]
description = """
End of patrol cycle decision.

```
                    +------------------+
                    |  Queue empty?    |
                    +--------+---------+
                             |
              +--------------+--------------+
              | YES                         | NO
              v                             v
    +---------------------+      +---------------------+
    | EXIT CLEANLY        |      | Context HIGH?       |
    | (no handoff)        |      +----------+----------+
    | Daemon will wake    |                 |
    | when work arrives   |      +----------+----------+
    +---------------------+      | YES                 | NO
                                 v                     v
                      +------------------+  +------------------+
                      | gt handoff       |  | Loop: spawn wisp |
                      | (successor       |  | return to        |
                      | continues queue) |  | inbox-check      |
                      +------------------+  +------------------+
```

**If queue EMPTY:**
- Squash wisp with summary digest
- EXIT cleanly - no handoff needed
- Daemon/witness will wake when MERGE_READY mail arrives

```bash
bd mol squash <wisp-id> --summary="Patrol complete: queue empty"
```

**If queue NON-EMPTY AND context HIGH:**
```bash
gt handoff -s "Patrol handoff" -m "Context limit reached.
Queue: N branches remaining
Processed: X merges, Y PRs created"
```

**If queue NON-EMPTY AND context LOW:**
```bash
bd mol squash <wisp-id> --summary="Patrol cycle complete"
bd mol spawn mol-refinery-patrol --wisp --assignee=refinery
```

**PRs waiting for merge:**
If PRs were created but not yet merged, this is expected. Exit cleanly.
The poll-pr-gates plugin monitors PR status. When PRs merge, GATE_CLEARED
mail triggers post-merge cleanup on the next patrol cycle."""
